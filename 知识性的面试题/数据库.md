# 注：此条目下只有一些抽象的东西，具体的参考另一个仓库mysqlstudy下的数据库笔记





## 数据库的三范式:

1NF：  每个列不能分割，即原子性。（能写到数据库里面）

2NF:    满足原子性情况下，每个非主属性依赖于主键，不存在部分依赖

3NF:    在2NF下，不存在函数传递依赖。就是数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖



## 数据库的三级模式：

(1)外模式又称子模式或用户模式，对应于用户级。它是某个或某几个用户所看到的数据库的数据视图，是与某一应用有关的数据的逻辑表示。外模式是从模式导出的一个子集，包含模式中允许特定用户使用的那部分数据。也可以利用数据操纵语言(Data Manipulation Language，DML)对这些数据记录进行操作。外模式反映了数据库系统的用户观。

(2)概念模式又称模式或逻辑模式，对应于概念级。它是由数据库设计者综合所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图(全局视图)。它是由数据库管理系统提供的数据模式描述语言(Data Description Language，DDL)来描述、定义的。概念模式反映了数据库系统的整体观。

(3)内模式又称存储模式，对应于物理级。它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。



(4)数据库系统在三级模式之间提供了两级映像：模式/内模式的映像、外模式/模式的映像。



- 物理数据独立性:    

  如果数据库的内模式要进行修改，即数据库的存储设备和存储方法有所变化，那么模式/内模式映象也要进行相应的修改，使概念模式尽可能保持不变。**也就是对模式的修改尽量不影响概念模式。**

  应用程序与储存在磁盘上数据库的物理模式是相互独立的。

- 逻辑数据独立性:

  如果数据库的概念模式要进行修改(如增加记录类型或增加数据项)，那么外模式/模式映象也要进行相应的修改，使外模式尽可能保持不变。**也就是对概念模式的修改尽量不影响外模式和应用程序。**

  应用程序与数据库中的逻辑结构相互独立。

 

## 数据库与xml之间有什么关系？

这是风牛马不相及的两个概念，他们的结构，应用范围是完全不同的，目前的数据库基本上都是关系型数据库，以sql与oracle为代表，都是非常大型的，可以进行数据的海量存储；而xml主要解决的是数据在网上传输标准的问题，把原来各种各样的数据孤岛可以通过xml这座桥梁连接起来，所以打个比方，数据库就好比是盛数据的桶，而xml则是数据传输转换的桥梁，所以数据库是数据库，xml是xml，二者是截然不同的，当然二者也存在非常紧密的联系，毕竟都是处理数据的工具，就是很多其他的数据格式可以通过xml输入到数据库中，数据库中的关系型数据也可以通过xml转化成其他的数据格式所以，不要因为他们都与数据有关，就把他们混为一谈



## 什么是存储过程？有哪些优缺点？

- 存储过程的优点：

  （1）能够将代码封装起来保存在数据库之中让编程语言进行调用
  （2）存储过程是一个预编译的代码块，执行效率比较高
  （3）一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率

- 缺点：

  （1)每个数据库的存储过程语法几乎都不一样，十分难以维护（不通用）

    (2)业务逻辑放在数据库上，难以迭代

  





版权声明：下面一条DQL,DML,DDL等的内容为CSDN博主「小贪玩」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u013544734/java/article/details/80869135

## SQL中有关DQL、DML、DDL、DCL的概念与区别

SQL结构化查询语言包含6个部分

1.数据查询语言（DQL: Data Query Language）

数据检索语句，用于从表中获取数据。通常最常用的为保留字SELECT,并且常与FROM子句、WHERE子句组成查询SQL查询语句。
语法：
    SELECT <字段名> FROM <表或视图名> WHERE <查询条件>;



2.数据操纵语言（DML：Data Manipulation Language）

主要用来对数据库的数据进行一些操作，常用的就是INSERT、UPDATE、DELETE。

语法：    INSERT INTO <表名>(列1,列2,...) VALUES (值1,值2,...);    

​				UPDATE <表名> SET <列名>=新值 WHERE <列名>=某值;    

​				DELETE FROM <表名> WHERE <列名>=某值;



3.事务处理语言（DPL）

事务处理语句能确保被DML语句影响的表的所有行及时得以更新。

DPL语句包括BEGIN TRANSACTION、COMMIT和ROLLBACK。



4.数据控制语言（DCL）

通过GRANT和REVOKE确定单个用户或用户组对数据库对象的访问权限。



5.数据定义语言（DDL）

常用的有CREATE和DROP，用于在数据库中创建新表或删除表，以及为表加入索引等。



6.指针控制语言（CCL）

它的语句，DECLARE CURSOR、FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。





## 索引详解：（暂缺）





事务的笔记转自https://blog.csdn.net/dengjili/article/details/82468576

## 事务:

#### ACID — 数据库事务正确执行的四个基本要素。

原子性（Atomicity）
原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。

一致性（Consistency）
事务前后数据的完整性必须保持一致。事务必须是使数据库从一个一致性状态变到另一个一致性状态。

隔离性（Isolation）
与并发有关。事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。

持久性（Durability）
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。



#### 一致性详解：

原子性并不能够完全保证一致性。

为了保证事务操作的原子性，必须实现基于日志的REDO/UNDO机制。

在事务处理的ACID属性中，一致性是最基本的属性，其它的三个属性都为了保证一致性而存在的。

在数据库实现的场景中，一致性可以分为数据库外部的一致性和数据库内部的一致性。前者由外部应用的编码来保证，即某个应用在执行转帐的数据库操作时，必须在同一个事务内部调用对帐户A和帐户B的操作。如果在这个层次出现错误，这不是数据库本身能够解决的，也不属于我们需要讨论的范围。后者由数据库来保证，即在同一个事务内部的一组操作必须全部执行成功（或者全部失败）。这就是事务处理的原子性。



#### 事务的隔离级别:

###### 	悲观锁与乐观锁:

​	悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

​	乐观锁
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

​	乐观锁适用于读多写少的情况。悲观锁反之。



###### 	乐观锁的实现,vesion方法：

在并发的表上加一个version字段，更新的时候只有版本号大于当前版本号才能更新成功，不成功的话可能是重来

```mysql
select money，version from account where id=10 for update
money = money + 100
version = version + 1
update account set money =  money where id =10 and version > version
```



###### 事务的并发问题:

脏读：指一个事务读取了另外一个事务未提交的数据。如果这时B事务恰巧进行了回滚事务，那么A事务读取的事务是不被承认的。（读到了没有提交的数据）

不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。（读到的数据有修改）

幻读:是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。

小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表



MySQL事务隔离级别

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| :--------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读(repeatable_read)    | 否   | 否         | 是   |
| 串行化(serializable)         | 否   | 否         | 否   |


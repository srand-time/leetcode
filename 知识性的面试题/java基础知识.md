

### JAVASCRIPT 和JSP不是同一个东西

1,JAVASCRIPT JavaScript 是一种新的描述语言，此一语言可以被箝入 HTML 的文件之中。透过 JavaScript 可以做到回应使用者的需求事件 (如： form 的输入) 而不用任何的网路来回传输资料，所以当一位使用者输入一项资料时，它不用经过传给伺服端 (server)处理，再传回来的过程，而直接可以被客户端 (client) 的应用程式所处理。你也可以想像成有一个可执行程式在你的客端上执行一样！目前已有一些写好的程式在Internet 上你可以连过去看看，以下有一些计算器的例子，在 Nescape 上。JavaScript 和 Java 很类似，但到底并不一样！ Java 是一种比 JavaScript 更复杂许多的程式语言，而 JavaScript 则是相当容易了解的语言。JavaScript 创作者可以不那麽注重程式技巧，所以许多 Java 的特性在 Java Script 中并不支援。

2,JSPJSP(Java Server Pages)是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准，JSP(Java Server Pages)是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。 JSP技术是用JAVA语言作为脚本语言的，JSP网页为整个服务器端的JAVA库单元提供了一个接口来服务于HTTP的应用程序。 在传统的网页HTML文件(*.htm,*.html)中加入Java程序片段(Scriptlet)和JSP标记(tag)，就构成了JSP网页(*.jsp)。Web服务器在遇到访问JSP网页的请求时，首先执行其中的程序片段，然后将执行结果以HTML格式返回给客户。程序片段可以操作数据库、重新定向网页以及发送 email 等等，这就是建立动态网站所需要的功能。所有程序操作都在服务器端执行，网络上传送给客户端的仅是得到的结果，对客户浏览器的要求最低，可以实现无Plugin，无ActiveX，无Java Applet，甚至无Frame。  

 JSP的优点：  ·对于用户界面的更新，其实就是由 Web Server进行的，所以给人的感觉更新很快。   ·所有的应用都是基于服务器的，所以它们可以时刻保持最新版本。   ·客户端的接口不是很繁琐，对于各种应用易于部署、维护和修改





### 下面哪些类可以被继承？Java.lang.Thread、java.lang.Number、java.lang.Double、java.lang.Math、 java.lang.ClassLoader

A，Thread可以被继承，用于创建新的线程

B，Number类可以被继承，Integer，Float，Double等都继承自Number类

C，Double类的声明为class="prettyprint">public final class Double extends Number implements

Comparable<Double>它被声明成了final类，所以不能被继承。

D.Math类的声明为：  public final class Mathextends Object ，不能被继承。

E.ClassLoader可以被继承，用户可以自定义类加载器。





### 请你讲讲UML中有哪些常用的图？

在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。 

统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言。UML使用面向对象设计的建模工具，但独立于任何具体程序设计语言。 
作用： 
(1)为软件系统建立可视化模型。
(2)为软件系统建立构件。
(3)为软件系统建立文档。
UML系统开发中有三个主要的模型：  
功能模型：从用户的角度展示系统的功能，包括用例图。 
对象模型：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类别图、对象图。 
动态模型：展现系统的内部行为。包括序列图，活动图，状态图。 









### 关于java import xxx.*对资源的占用的说明

import xxx.*并不会对性能或资源造成影响，如果要说影响，可能就是对代码可读性的影响，比如没删除无用的引入上面总是显示灰色不太美观，或者使用*之后不能直观的看出此类引入了哪些类库等等，类似书写规范的要求。当然，有一种情况是你使用了两个类库的同名类，会导致引用矛盾，不过这种情况像idea等编辑器会直接报错。





## 高效并发：（未完）

### 1.进程:

转自https://www.cnblogs.com/fengff/p/9622026.html

##### （1）进程的概念

进程是可并发执行的程序在某个数据集合上的一次计算活动，也是操作系统进行资源分配和调度的基本单位。



##### （2）进程与程序的联系与区别

① 程序是指令的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态的概念。
② 程序可以作为一种软件资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的。
注：程序可看作一个菜谱，而进程则是按照菜谱进行烹调的过程。
③ 进程和程序组成不同：进程是由程序、数据和进程控制块三部分组成的。
④ 进程与程序的对应关系：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。



##### （3）进程的特征

动态性：进程是程序的执行，同时进程有生命周期。
并发性：多个进程可同存于内存中，能在一段时间内同时执行。
独立性：资源分配和调度的基本单位。
制约性：并发进程间存在制约关系，造成程序执行速度不可预测性，必须对进程的并发执行次序、相对执行速度加以协调。
结构特征：进程由程序块 、数据块、进程控制块三部分组成。



##### (4)进程的三种基本状态：

@运行态(running)
当进程得到处理机，其执行程序正在处理机上运行时的状态称为运行状态。
在单CPU系统中，任何时刻最多只有一个进程处于运行状态。在多CPU系统中，处于运行状态的进程数最多为处理机的数目。
@就绪状态(ready)
当一个进程已经准备就绪，一旦得到CPU，就可立即运行，这时进程所处的状态称为就绪状态。系统中有一个就绪进程队列，处于就绪状态进程按某种调度策略存在于该队列中。
@等待态（阻塞态）（Wait / Blocked ）
若一个进程正等待着某一事件发生(如等待输入输出操作的完成)而暂时停止执行的状态称为等待状态。      处于等待状态的进程不具备运行的条件，即使给它CPU，也无法执行。系统中有几个等待进程队列（按等待的事件组成相应的等待队列）。

运行到等待：等待某事件的发生（如等待I/O完成）
等待到就绪：事件已经发生（如I/O完成）
运行到就绪：时间片到（例如，两节课时间到，下课）或出现更高优先级进程，当前进程被迫让出处理器。
就绪到运行：当处理机空闭时，由调度（分派）程序从就绪进程队列中选择一个进程占用CPU。
  上述三种状态是进程最基本的状态，在实际的操作系统实现中，进程远不止这三种状态。



##### (5)进程为什么要有“挂起”状态?

​      由于系统不断创建进程，系统资源特别是主存已不能满足进程运行要求，此时必须将某些进程挂起（suspend），置于磁盘对换区，释放其所占资源，暂时不启用低级调度，起到平滑负载的目的。



##### (6)进程的描述和组成

进程内容及其状态集合称为进程映像。包括：

进程控制块：每个进程有一进程控制块，用来存储进程的标识信息、现场信息和控制信息。

程序块：
核心栈：每个进程捆绑一个核心栈，进程在核心态工作时，用来保存中断/异常现场等。
数据块：存放程序私有数据，用户栈也在数据块中开辟。



##### （7）进程上下文

操作系统中把进程物理实体和支持进程运行的环境合称为进程上下文。
进程在其当前上下文中运行，当系统调度新进程占有处理器时，新老进程随之发生上下文切换。即保存老进程状态而装入被保护了的新进程的状态，以便新进程运行

##### （8）进程上下文组成

用户级上下文：由正文（程序）、数据、共享存储区、用户栈组成，占用进程的虚地址空间。
存器上下文：由程序状态字寄存器、指令计数器、栈指针、控制寄存器、通用寄存器等组成。
系统级上下文：由进程控制块、主存管理信息（页表或段表）、核心栈等组成。

##### (9)进程控制块（Process Control Block，PCB）

每个进程有且仅有一个进程控制块

PCB是操作系统用于记录和刻划进程状态及有关信息的数据结构，是操作系统掌握进程的唯一资料结构。
系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志
进程与PCB是一一对应的,在创建进程时，建立PCB，并伴随进程运行的全过程，直到进程撤消而撤消。PCB就象我们的户口。

进程控制块PCB中的内容：
①标识信息
进程标识ID：唯一，通常是一个整数
进程组标识ID
用户进程名
用户组名
②现场信息
寄存器内容（通用寄存器内容、控制寄存器内容、栈指针等）
③控制信息
进程调度信息：如进程状态、等待时间、等待原因、进程优先级、队列指针等
进程组成信息：如正文段指针、数据段指针、进程族系信息
进程间通信信息：如消息队列指针、所使用的信号量和锁
进程段、页表指针、进程映像在辅存地址
CPU的占用和使用信息：如时间片剩余量、已占用CPU时间、已执行时间总和、定时器信息、记账信息
进程特权信息：如主存访问权限、处理器特权
资源清单：所需全部资源、已分得资源



##### (10)进程队列及其管理

处于同一状态的所有PCB组织在一起的数据结构称为进程队列。例如运行队列、就绪队列、等待队列。
同一状态进程的PCB既可按先来先到的原则排成队列;也可按优先数或其它原则排成队列。

通用队列组织方式：
    线性方式
    链接方式
    索引方式

@线性方式
OS根据进程的最大数目，静态分配主存中某块空间，所有进程的PCB都组织在一个线性表中。
优点：简单易行；
缺点：限定了系统中进程最大数，
      经常要扫描整个线性表，调度效率较低。
@链接方式
相同状态的进程PCB通过链接指针链接成一个队列。
不同状态的进程可排成不同的队列，如运行队列、就绪队列、等待队列。等待队列按等待原因不同可排成多个等待队列。
@索引方式
对具有相同状态的进程，分别设置各自的PCB索引表，如就绪索引表、等待索引表，记录PCB在PCB表中的地址.



##### (11)进程切换

一个进程让出处理器，由另一个进程占用处理器的过程称为进程切换。
进程的切换使系统中的各进程均有机会占用CPU。
进程切换的步骤
保存被中断进程的处理器现场信息
修改被中断进程的进程控制块的有关信息，如进程状态等
把被中断进程的进程控制块加入有关队列
选择下一个占有处理器运行的进程
修改被选中进程的进程控制块的有关信息
根据被选中进程设置操作系统用到的地址转换和存储保护信息
根据被选中进程恢复处理器现场



##### (12)进程的控制和管理:

进程是有生命周期的：产生、运行、暂停、终止。进程生命周期的动态变化过程由进程管理程序来控制。
进程的控制和管理包括：
   进程创建
   进程撤消
   进程阻塞
   进程唤醒
   进程挂起
   进程激活
这些控制和管理功能由操作系统中的原语实现。
原语是在核心态执行、完成系统特定功能的不可分割的过程。
原语的特点是执行过程中不允许被中断，是一个不可分割的基本单位，原语的执行是顺序的而不可能是并发的。

### 3.线程与进程的比较

线程具有进程的许多特征，故又称轻型进程，传统进程称重型进程。
在引入线程的OS中，每一进程都拥有多个线程，至少一个。
(1)调度
在传统OS中，拥有资源、独立调度和分派的基本单位都是进程，在引入线程的系统中，线程是调度和分派的基本单位，而进程是拥有资源的基本单位。
在同一个进程内线程切换不会产生进程切换，由一个进程内的线程切换到另一个进程内的线程时，将会引起进程切换。
(2)并发性
在引入线程的系统中，进程之间可并发，同一进程内的各线程之间也能并发执行。因而系统具有更好的并发性。
(3)拥有资源
无论是传统OS，还是引入线程的OS，进程都是拥有资源的独立单位，线程一般不拥有系统资源，但它可以访问隶属进程的资源。即一个进程的所有资源可供进程内的所有线程共享。
(4)系统开销
进程的创建和撤消的开销要远大于线程创建和撤消的开销，进程切换时，当前进程的CPU环境要保存，新进程的CPU环境要设置，线程切换时只须保存和设置少量寄存器，并不涉及存储管理方面的操作，可见，进程切换的开销远大于线程切换的开销。
同时，同一进程内的各线程由于它们拥有相同的地址空间，它们之间的同步和通信的实现也变得比较容易。



举例说明：

计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。

假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。

进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。

一个车间里，可以有很多工人。他们协同完成一个任务。

线程就好比车间里的工人。一个进程可以包括多个线程。

车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。

可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。

一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫"互斥锁"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。

还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。

这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做"信号量"（Semaphore），用来保证多个线程不会互相冲突。
不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。

